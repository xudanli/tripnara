import {
  Injectable,
  Logger,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { ItineraryRepository } from '../../persistence/repositories/itinerary/itinerary.repository';
import {
  TaskDto,
  TaskListResponseDto,
  SyncTasksRequestDto,
  SyncTasksResponseDto,
  UpdateTaskRequestDto,
  UpdateTaskResponseDto,
  DeleteTaskResponseDto,
  CreateTaskRequestDto,
  CreateTaskResponseDto,
} from '../dto/itinerary.dto';

@Injectable()
export class JourneyTaskService {
  private readonly logger = new Logger(JourneyTaskService.name);

  constructor(
    private readonly itineraryRepository: ItineraryRepository,
  ) {}

  /**
   * 获取行程任务列表
   * 添加重试机制，解决偶发的"不存在"报错
   */
  async getJourneyTasks(
    journeyId: string,
    userId: string,
  ): Promise<TaskListResponseDto> {
    // 检查所有权
    const isOwner = await this.itineraryRepository.checkOwnership(
      journeyId,
      userId,
    );
    if (!isOwner) {
      throw new ForbiddenException('无权访问此行程');
    }

    // 添加重试机制，解决偶发的"不存在"报错
    // 可能原因：事务提交延迟、数据库复制延迟、缓存不一致等
    const maxRetries = 3;
    const retryDelay = 100; // 100ms

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const tasks = await this.itineraryRepository.getTasks(journeyId);
        return {
          tasks: tasks as unknown as TaskDto[],
        };
      } catch (error) {
        // 如果是最后一次尝试，重新抛出错误
        if (attempt === maxRetries) {
          this.logger.error(
            `[getJourneyTasks] Failed to get tasks for journey ${journeyId} after ${maxRetries} attempts:`,
            error instanceof Error ? error.message : error,
          );
          throw error;
        }
        // 否则等待后重试
        this.logger.debug(
          `[getJourneyTasks] Error getting tasks for journey ${journeyId}, retrying (attempt ${attempt}/${maxRetries}):`,
          error instanceof Error ? error.message : error,
        );
        await new Promise((resolve) =>
          setTimeout(resolve, retryDelay * attempt),
        );
      }
    }

    // 理论上不会到达这里，但为了类型安全
    throw new Error('获取行程任务失败');
  }

  /**
   * 同步任务（根据目的地/模板重新生成并合并）
   */
  async syncJourneyTasks(
    journeyId: string,
    userId: string,
    dto: SyncTasksRequestDto,
    getItineraryTemplateById?: (templateId: string) => Promise<any>,
  ): Promise<SyncTasksResponseDto> {
    // 检查所有权
    const isOwner = await this.itineraryRepository.checkOwnership(
      journeyId,
      userId,
    );
    if (!isOwner) {
      throw new ForbiddenException('无权修改此行程');
    }

    // 性能优化：查询一次，后续复用
    const itinerary = await this.itineraryRepository.findById(journeyId);
    if (!itinerary) {
      throw new NotFoundException(`行程不存在: ${journeyId}`);
    }

    let newTasks: TaskDto[] = [];

    // 如果指定了模板ID，从模板获取任务
    if (dto.templateId && getItineraryTemplateById) {
      const templateDetail = await getItineraryTemplateById(dto.templateId);
      if (templateDetail && templateDetail.tasks) {
        newTasks = templateDetail.tasks || [];
      }
    }

    // 根据目的地生成任务（如果强制重新生成或没有任务）
    if (dto.forceRegenerate || newTasks.length === 0) {
      // TODO: 调用 AI 生成任务（这里先使用占位符）
      const aiGeneratedTasks: TaskDto[] = [
        {
          title: `确认护照有效期及前往 ${itinerary.destination} 是否需要签证/入境许可`,
          completed: false,
          category: 'preparation',
          destination: itinerary.destination,
          links: [
            {
              label: 'IATA 入境政策查询',
              url: 'https://www.iatatravelcentre.com/',
            },
          ],
        },
        {
          title: `预订往返 ${itinerary.destination} 的核心交通（机票/火车），并关注托运行李政策`,
          completed: false,
          category: 'preparation',
          destination: itinerary.destination,
          links: [
            {
              label: 'OAG 行李政策汇总',
              url: 'https://www.oag.com/baggage-allowance',
            },
          ],
        },
      ];

      // 合并 AI 生成的任务
      newTasks = [...newTasks, ...aiGeneratedTasks];
    }

    // 获取现有任务
    const existingTasks = (await this.itineraryRepository.getTasks(
      journeyId,
    )) as unknown as TaskDto[];

    // 合并任务（去重，基于 title 或 autoKey）
    const taskMap = new Map<string, TaskDto>();

    // 先添加现有任务
    existingTasks.forEach((task) => {
      const key = task.autoKey || task.title;
      if (key && !taskMap.has(key)) {
        taskMap.set(key, task);
      }
    });

    // 添加新任务（如果不存在）
    newTasks.forEach((task) => {
      const key = task.autoKey || task.title;
      if (key && !taskMap.has(key)) {
        task.autoGenerated = true;
        taskMap.set(key, task);
      }
    });

    const mergedTasks = Array.from(taskMap.values());
    await this.itineraryRepository.updateTasks(
      journeyId,
      mergedTasks as unknown as Array<Record<string, unknown>>,
    );

    return {
      success: true,
      tasks: mergedTasks,
      message: '同步成功',
    };
  }

  /**
   * 更新任务
   */
  async updateJourneyTask(
    journeyId: string,
    taskId: string,
    userId: string,
    dto: UpdateTaskRequestDto,
  ): Promise<UpdateTaskResponseDto> {
    // 检查所有权
    const isOwner = await this.itineraryRepository.checkOwnership(
      journeyId,
      userId,
    );
    if (!isOwner) {
      throw new ForbiddenException('无权修改此行程');
    }

    const updates: Partial<TaskDto> = {};
    if (dto.title !== undefined) updates.title = dto.title;
    if (dto.completed !== undefined) updates.completed = dto.completed;
    if (dto.links !== undefined) updates.links = dto.links;

    const tasks = await this.itineraryRepository.updateTask(
      journeyId,
      taskId,
      updates as Partial<Record<string, unknown>>,
    );

    const updatedTask = tasks.find(
      (t) => (t as unknown as TaskDto).id === taskId,
    ) as unknown as TaskDto;
    if (!updatedTask) {
      throw new NotFoundException(`任务不存在: ${taskId}`);
    }

    return {
      success: true,
      task: updatedTask,
      message: '更新成功',
    };
  }

  /**
   * 删除任务
   */
  async deleteJourneyTask(
    journeyId: string,
    taskId: string,
    userId: string,
  ): Promise<DeleteTaskResponseDto> {
    // 检查所有权
    const isOwner = await this.itineraryRepository.checkOwnership(
      journeyId,
      userId,
    );
    if (!isOwner) {
      throw new ForbiddenException('无权修改此行程');
    }

    await this.itineraryRepository.deleteTask(journeyId, taskId);

    return {
      success: true,
      message: '删除成功',
    };
  }

  /**
   * 创建任务
   */
  async createJourneyTask(
    journeyId: string,
    userId: string,
    dto: CreateTaskRequestDto,
  ): Promise<CreateTaskResponseDto> {
    // 检查所有权
    const isOwner = await this.itineraryRepository.checkOwnership(
      journeyId,
      userId,
    );
    if (!isOwner) {
      throw new ForbiddenException('无权修改此行程');
    }

    const newTask: TaskDto = {
      title: dto.title,
      completed: false,
      category: dto.category,
      destination: dto.destination,
      links: dto.links,
      autoGenerated: false,
      createdAt: Date.now(),
    };

    const tasks = await this.itineraryRepository.addTask(
      journeyId,
      newTask as unknown as Record<string, unknown>,
    );

    const createdTask = tasks[tasks.length - 1] as unknown as TaskDto;

    return {
      success: true,
      task: createdTask,
      message: '创建成功',
    };
  }
}

